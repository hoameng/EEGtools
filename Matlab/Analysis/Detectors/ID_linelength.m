function output = JensenLL(data, params, fs, curTime)
% Usage: f_burst_linelength(dataset, params)
% Input: 
%   'dataset'   -   [IEEGDataset]: IEEG Dataset, eg session.data(1)
%   'params'    -   Structure containing parameters for the analysis
% 
%   dbstop in ID_linelength at 23

  %%-----------------------------------------
  %%---  parameters for custom feature
  IDfunction = @(x) (sum(abs(diff(x)))); % default feature function
  minDuration = 5; % sec; default min duration of detection
  maxDuration = 100; % sec; default min duration of detection
  minThreshold = 3e2; % default min threshold for detection
  maxThreshold = 4 * minThreshold; % default max threshold for detection
  windowLength = 2; % sec, default duration of sliding window
  windowDisplacement = 1; % sec, default amount to slide window
  smoothDur = 5; % sec; default width of smoothing window
  %%---  parameters for custom feature
  
  %%---  custom feature creation and data processing
  % calculate number of sliding windows (overlap is ok)
  NumWins = @(xLen, fs, winLen, winDisp) (xLen/fs)/winDisp-(winLen/winDisp-1); 
  nw = int64(NumWins(length(data), fs, params.InitialDetection.default.windowLength, ...
    params.InitialDetection.default.windowDisplacement));
  timeOut = zeros(nw,1);
  featureOut = zeros(nw, length(params.DatasetInfo.channelsToRun));

  % filter then normalize each channel by std of entire data block
  origData = data;
  data = high_pass_filter(data, fs);
  data = low_pass_filter(data, fs);
  rmsdata = rms(data,1);
  rmsdata(rmsdata > params.InitialDetection.default.minThreshold) = NaN;
  filtOut = data ./ repmat(rmsdata,size(data,1),1);
%   normalizer = max(std(data)) ./ std(data);
%   for c = 1: length(params.channels)
%     data(:,c) = data(:,c) .* normalizer(c);
%   end

%   % low-pass filter
%   filtOut = low_pass_filter(data, fs); % see below

  % for each window, calculate feature as defined in params
  for w = 1: nw
    winBeg = params.InitialDetection.default.windowDisplacement * fs * (w-1) + 1;
    winEnd = min([winBeg+params.InitialDetection.default.windowLength*fs-1 length(filtOut)]);
    timeOut(w) = winEnd/fs*1e6 + curTime;         % right-aligned
    featureOut(w,:) = params.InitialDetection.default.function(filtOut(winBeg:winEnd,:)); 
  end

  % smooth window using convolution 
  if params.InitialDetection.default.smoothDur > 0
    smoothLength = 1/params.InitialDetection.default.windowDisplacement ...
      * params.InitialDetection.default.smoothDur; % in samples of data signal
    smoother =  1 / smoothLength * ones(1,smoothLength);
    for c = 1: length(params.DatasetInfo.channelsToRun)
      featureOut(:,c) = conv(featureOut(:,c),smoother,'same');
    end
  end
  output = [timeOut featureOut];
  %%---  custom feature creation and data processing
  %%-----------------------------------------
end


function y = low_pass_filter(x,Fs)
  % MATLAB Code
  % Generated by MATLAB(R) 8.2 and the DSP System Toolbox 8.5.
  % Generated on: 09-Mar-2015 11:44:09

  persistent Hd;

  if isempty(Hd)

    N     = 4;     % Order
    F3dB  = 50;    % 3-dB Frequency
    Apass = 1;     % Passband Ripple (dB)

    h = fdesign.lowpass('n,f3db,ap', N, F3dB, Apass, Fs);

    Hd = design(h, 'cheby1', ...
      'SOSScaleNorm', 'Linf');

    set(Hd,'PersistentMemory',true);

  end

  y = filtfilt(Hd.sosMatrix, Hd.ScaleValues, x);
%  y = filter(Hd,x);
end

function y = high_pass_filter(x, Fs)
  % MATLAB Code
  % Generated by MATLAB(R) 8.2 and the DSP System Toolbox 8.5.
  % Generated on: 04-Mar-2015 10:14:48

  persistent Hd;

  if isempty(Hd)

    N     = 3;    % Order
    F3dB  = 4;     % 3-dB Frequency
    Apass = 1;     % Passband Ripple (dB)

    h = fdesign.highpass('n,f3db,ap', N, F3dB, Apass, Fs);

    Hd = design(h, 'cheby1', ...
      'SOSScaleNorm', 'Linf');

    set(Hd,'PersistentMemory',true);

  end
  
  y = filtfilt(Hd.sosMatrix, Hd.ScaleValues, x);
%   y = filtfilt(h,x);
end

